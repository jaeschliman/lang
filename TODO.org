* DONE stack traces
* DONE move allocations into vm-managed heap
* DONE lists (incl printing)
* DONE lisp reader
* DONE expression compiler
* DONE lambda compiler
* DONE lambdas + closures compiler
* DONE def or define or something
* DONE varargs
* DONE vararg lambda
* DONE quasiquotation
* DONE booleans
* DONE characters
* DONE obj_size function // heap size of object (can be 0 for imms)
* DONE obj_ptrs function // walk Ptr s of obj (use a lambda)
* DONE make stack frames objects
* DONE read string
* TODO tests! (something like an assert)
* DONE bounds checking for heap allocation
* DONE memory usage report function
* DONE if compiler
* DONE simple let
* DONE let + closures
* TODO move symbol table into heap (make it an object)
* DONE vm_map_stack_refs(VM *vm, PtrFn)
* DONE vm_map_reachable_refs(VM *vm) function
* DONE maybe replace 'ffi' with primitives array (simpler for dump/restore?)
* DONE code-generate the prims table. elisp?
* DONE remove the 'ffi' stuff
* DONE scan_heap(mem *start, mem*end) fn (linear scan of objects on the heap)
* DONE garbage collection (cheney?)
* DONE initial audit of requred gc_protect calls
* DONE gc_protect for ptrs
* DONE gc-safe list manipulation functions
* DONE gc-safe allocators / make- functions
* DONE growable ptr array
* DONE growable identity map
* DONE gc-safe reader
* DONE gc-safe BCBuilder
* DONE move varinfo & CompilerEnv into gc heap
* DONE gc-safe compiler
* DONE automatic garbage collection (need to use gc_protect)
* DONE identity hash function
* DONE proper imap
* DONE make cons a defstruct
* TODO move stack memory into vm-managed heap
* DONE stack overlow detection
* TODO continuations / exceptions / signals
* TODO dump/restore image
* DONE write macroexpander in the language itself
* TODO write reader in the language itself
* DONE basic sdl integration
* DONE single floats
* TODO U32 Array etc
* DONE more prim instrs
* TODO maybe expose bytecode prims as special forms? %push %call etc...
* TODO growable heap
* TODO looping special form (while?)
* TODO TCO
* DONE set!
* TODO set! for more binding contexts
* DONE repl
* TODO basic notebook
* TODO notebook w/ event reactor
* DONE 'load file' vs run file
* TODO rewrite the codegen in the lang itself 
* DONE 'apply'
* DONE basic 'event reactor' runloop -- start with keycodes
* TODO optimize global calls for more arities
* DONE point functions
* DONE real 'built-in-classes' i.e. Cons Fixnum etc
* DONE basic message definition, send facility
* DONE image objects
* DONE rotation + scale BitBlt like thing
* TODO maybe store image data off-heap?
* DONE fix make-point for negative values (was a reader problem)
* DONE more compact bc representation
* TODO compact more of the bc
* DONE generalize blit to work b/t images as well
* DONE blit with mask, src rect, scale, rotation (for both mask and src)
* DONE message send facility
* DONE something resembling OMeta / Meta II
  not as many features, by a long shot, but something basic appears to be working
* TODO optionally plugin in Meta reader as program reader
* DONE basic text rendering
  (very, very basic)
* TODO type-of
* DONE class-of
* DONE better float printing (may be missing trailing .0)
* DONE float exponent support?
* TODO more correct float reading support
* TODO unified 'number' type?
* TODO bignums
* TODO clean up callsites of blit- functions
* TODO runtime argument count checking for prims and lambdas
* TODO run on an ipad!
* TODO only update dirty rects?
SDL_UpdateWindowSurfaceRects
https://wiki.libsdl.org/SDL_UpdateWindowSurfaceRects
* TODO warp blit
* TODO simple slideshow program
* TODO ? basic per-file modules ?
* TODO add counters to gensym
* TODO sexpr dot-reader
* TODO audit uses of *_mem functions for GC safety
* DONE apparently we are leaking like crazy somewhere...
* TODO make the lisp programs objects that respond to messages
* TODO ability to load files at the repl
* TODO basic debugger (not that we save debug info, but...)
* TODO some WEIRD bug around hashing -- was seeing the same object change hash codes
  may need to confirm that hash persists across GCs
  by all means it should


* notes
maybe have a stack of compilers? can push/pop...
have each compiler pass output to previous one in the stack

how to represent U32 and U64?

how will we pass callbacks through to the VM?  e.g. if I want to map
values of a ht?  safe to 'just' push a stack frame?  but how do we
yield control to the vm, and get it back?

RE: storing image data off-heap: could have a 'byte-blob' object type.
after a gc, scan the old heap for byte-blobs that are not broken hearts,
and free the mem. it's a tradeoff, two heap scans, but less copying.
could become important as there will eventually be many images

RE: meta, would be nice if could have `contextual` in-expr meta, so
that the meta runtime could `push` and `pop` match systems:

(define (copy-from-to a b)
  (let ((i 0))
    (while (< i (length a))
      ;; here we push the `idx` reader which adds supports for subscripts
      ;; for a single expression
      #m idx (set! b[i] i[i])
      (set! i (+ 1 i)))))

also would be nice to add support for arguments, as is done in OMeta
and col/line error reporting :P
