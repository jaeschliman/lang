(defmacro forever (& forms)
  `(let ((loop #f))
     (set! loop (lambda () ,@forms (loop)))
     (loop)))

(define mouse-position 0@0)
(define boxes '())
(define screen-size #f)
(define back-buffer #f)

(define (ordered? a b c)
    (and (<i a b) (<i b c)))

(define (move-box box)
    (let* ((x (aget box 0))
           (y (aget box 1))
           (dx (aget box 2))
           (dy (aget box 3))
           (nx (+i x dx))
           (ny (+i y dy))
           (sw (point-x screen-size))
           (sh (point-y screen-size))
           (mx (point-x mouse-position))
           (my (point-y mouse-position)))
      (when (<i nx 0)
        (set! nx 0)
        (set! dx (*i -1 dx)))
      (when (<i ny 0)
        (set! ny 0)
        (set! dy (*i -1 dy)))
      (when (>i nx sw)
        (set! nx sw)
        (set! dx (*i -1 dx)))
      (when (>i ny sh)
        (set! ny sh)
        (set! dy (*i -1 dy)))
      (let ((mouseover (and (ordered? nx mx (+i 15 nx))
                            (ordered? ny my (+i 15 ny)))))
        (when mouseover
          (kill-thread (current-thread)))
        (if mouseover
            (aset box 4 0xff0000ff)
            (aset box 4 0xff00ffff))
        (unless mouseover
          (aset box 0 nx)
          (aset box 1 ny)
          (aset box 2 dx)
          (aset box 3 dy)))))

(define (add-box p)
    (let ((box (make-array 5)))
      (aset box 0 (point-x p))
      (aset box 1 (point-y p))
      (aset box 2 1)
      (aset box 3 1)
      (aset box 4  0xff00ffff)
      (set 'boxes (cons box boxes))
      (fork-with-priority 0 (forever
                             (sleep-ms 16)
                             (move-box box)))))

(define (clear-screen)
    (fill-rect back-buffer 0@0 screen-size 0xffffffff))

(define (flip-buffer)
    (blit-to-screen back-buffer 0@0 100 0))

(define (draw-one-box box)
    (let* ((x (aget box 0))
           (y (aget box 1))
           (color (aget box 4))
           (a (make-point x y))
           (b (point+ a 10@10)))
      (fill-rect back-buffer a b color)))

(define (draw-boxes)
    (let ((loop #f))
      (set! loop (lambda (remaining)
                   (unless (nil? remaining)
                     (draw-one-box (car remaining))
                     (loop (cdr remaining)))))
      (loop boxes)))

(define (draw-frame)
    (clear-screen)
  (draw-boxes)
  (flip-buffer))

(define (onshow w h)
    (set 'screen-size (make-point w h))
  (set 'back-buffer (make-image w h))
  (fork-with-priority 100 (forever (draw-frame) (sleep-ms 10))))

(define got-event (make-semaphore 0))

(define (handle-event e)
    (let ((name (car e))
          (data (cdr e)))
      (case name
        (onmousedown (add-box data))
        (onmousedrag (add-box data) (set 'mouse-position data))
        (onmousemove (set 'mouse-position data)))))

(define pending-events '())

(define (poll-for-pending-events)
    (semaphore-wait got-event)
  ;; (print `(got event!))
  (let ((found pending-events)) ;; clearly not thread safe ; )
    (when (not (nil? found))
      (set 'pending-events '()) 
      (mapcar handle-event (reverse-list found)))))

(fork (forever (poll-for-pending-events)))

(define (add-event name data)
    (set 'pending-events (cons (cons name data) pending-events))
  (signal-semaphore got-event))

(define (onmousedown p) (add-event 'onmousedown p))
(define (onmousedrag p) (add-event 'onmousedrag p))
(define (onmousemove p) (add-event 'onmousemove p))
