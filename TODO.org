* DONE stack traces
* DONE move allocations into vm-managed heap
* DONE lists (incl printing)
* DONE lisp reader
* DONE expression compiler
* DONE lambda compiler
* DONE lambdas + closures compiler
* DONE def or define or something
* DONE varargs
* DONE vararg lambda
* DONE quasiquotation
* DONE booleans
* DONE characters
* DONE obj_size function // heap size of object (can be 0 for imms)
* DONE obj_ptrs function // walk Ptr s of obj (use a lambda)
* DONE make stack frames objects
* DONE read string
* DONE tests! (something like an assert)
* DONE bounds checking for heap allocation
* DONE memory usage report function
* DONE if compiler
* DONE simple let
* DONE let + closures
* TODO move symbol table into heap (make it an object)
* DONE vm_map_stack_refs(VM *vm, PtrFn)
* DONE vm_map_reachable_refs(VM *vm) function
* DONE maybe replace 'ffi' with primitives array (simpler for dump/restore?)
* DONE code-generate the prims table. elisp?
* DONE remove the 'ffi' stuff
* DONE scan_heap(mem *start, mem*end) fn (linear scan of objects on the heap)
* DONE garbage collection (cheney?)
* DONE initial audit of requred gc_protect calls
* DONE gc_protect for ptrs
* DONE gc-safe list manipulation functions
* DONE gc-safe allocators / make- functions
* DONE growable ptr array
* DONE growable identity map
* DONE gc-safe reader
* DONE gc-safe BCBuilder
* DONE move varinfo & CompilerEnv into gc heap
* DONE gc-safe compiler
* DONE automatic garbage collection (need to use gc_protect)
* DONE identity hash function
* DONE proper imap
* DONE make cons a defstruct
* TODO move stack memory into vm-managed heap
* DONE stack overlow detection
* DONE continuations / exceptions
* TODO signals
* TODO dump/restore image
* DONE write macroexpander in the language itself
* DONE write reader in the language itself
* DONE basic sdl integration
* DONE single floats
* TODO U32 Array etc
* DONE more prim instrs
* TODO maybe expose bytecode prims as special forms? %push %call etc...
* TODO growable heap
* TODO looping special form (while?)
* DONE TCO
* DONE set!
* TODO set! for more binding contexts
* DONE repl
* TODO basic notebook
* TODO notebook w/ event reactor
* DONE 'load file' vs run file
* TODO rewrite the codegen in the lang itself 
* DONE 'apply'
* DONE basic 'event reactor' runloop -- start with keycodes
* TODO optimize global calls for more arities
* DONE point functions
* DONE real 'built-in-classes' i.e. Cons Fixnum etc
* DONE basic message definition, send facility
* DONE image objects
* DONE rotation + scale BitBlt like thing
* TODO maybe store image data off-heap?
* DONE fix make-point for negative values (was a reader problem)
* DONE more compact bc representation
* TODO compact more of the bc
* DONE generalize blit to work b/t images as well
* DONE blit with mask, src rect, scale, rotation (for both mask and src)
* DONE message send facility
* DONE something resembling OMeta / Meta II
  not as many features, by a long shot, but something basic appears to be working
* DONE optionally plugin in Meta reader as program reader
* DONE basic text rendering
  (very, very basic)
* TODO type-of
* DONE class-of
* DONE better float printing (may be missing trailing .0)
* DONE float exponent support?
* TODO more correct float reading support
* TODO unified 'number' type?
* TODO bignums
* TODO clean up callsites of blit- functions
* TODO runtime argument count checking for prims and lambdas
* TODO run on an ipad!
* TODO only update dirty rects?
SDL_UpdateWindowSurfaceRects
https://wiki.libsdl.org/SDL_UpdateWindowSurfaceRects
* TODO warp blit
* TODO simple slideshow program
* TODO ? basic per-file modules ?
* TODO add counters to gensym
* TODO sexpr dot-reader
* TODO audit uses of *_mem functions for GC safety
* DONE apparently we are leaking like crazy somewhere...
* TODO make the lisp programs objects that respond to messages
* TODO ability to load files at the repl
* TODO basic debugger (not that we save debug info, but...)
* TODO some WEIRD bug around hashing -- was seeing the same object change hash codes
  may need to confirm that hash persists across GCs
  by all means it should
* TODO idea: _subclassable_ generic functions
 so each type invocation is a message, and you can subclass the function,
 and so override specific messages.
... but ... not sure if I want subclassing at all...
* TODO multiple return values? check scheme syntax
* TODO 'toplevel' do -- compile/execute exprs sequentially
* TODO some kind of module/object system for L programs
* TODO hygienic macros
http://www.cs.utah.edu/plt/scope-sets/
* TODO read this dissertation on implmentation of scheme
https://www.cs.indiana.edu/~dyb/papers/3imp.pdf
* DONE simple userspace structs (StandardObject)
* TODO convert BC to 32 bit so we can assemble from user space
* TODO adaptons? (see will byrd miniAdapton)
http://adapton.org/
* TODO bezier + fourier transforms is cool!
http://www.jezzamon.com/fourier/index.html
* TODO CFFI
* DONE basic green threading
* DONE basic special variables
* TODO wierd bug -- off-by-one error in vm->pc at termination of final thread
* TODO work out threading issues with run_file
* DONE clean up (new BCBuilder(vm)) callsites (ensure delete)
* TODO CAS for object slots
* TODO userspace print-object (requires output stream)
* TODO a GUI
* TODO a smalltalk-like
* TODO an actor system
* TODO a prolog
* DONE fix special variable integration with continuations
* DONE more thread manipulation functions
  (current-thread)
  (kill-thread thread)
* TODO list-all-threads, thread-status
* DONE semaphore
* TODO mutex etc
* DONE use bitmask for 'primitive' primOps (aka @send apply etc)
* TODO generic maths
* TODO a package system
* TODO hash tables need to grow after threshold

* notes
maybe have a stack of compilers? can push/pop...
have each compiler pass output to previous one in the stack

how to represent U32 and U64?

how will we pass callbacks through to the VM?  e.g. if I want to map
values of a ht?  safe to 'just' push a stack frame?  but how do we
yield control to the vm, and get it back?

RE: storing image data off-heap: could have a 'byte-blob' object type.
after a gc, scan the old heap for byte-blobs that are not broken hearts,
and free the mem. it's a tradeoff, two heap scans, but less copying.
could become important as there will eventually be many images

RE: meta, would be nice if could have `contextual` in-expr meta, so
that the meta runtime could `push` and `pop` match systems:

(define (copy-from-to a b)
  (let ((i 0))
    (while (< i (length a))
      ;; here we push the `idx` reader which adds supports for subscripts
      ;; for a single expression
      #m idx (set! b[i] i[i])
      (set! i (+ 1 i)))))

(this is actually spelled out in the ometa paper)

also would be nice to add support for arguments, as is done in OMeta
and col/line error reporting :P

need to learn about hygienic macro expansion
need to learn about scm module systems? it looks like racket has a nice one.

I have also been thinking about how to make lisp programs objects.
I want them to respond to messages.

I am wondering if the program should be 'instantiated' or are they
singletons?  it would be a bit hard to know how to parse/update the
class from the editor, or maybe I'm overthinking it?

So a Program would have some sort of contructor (or maybe a couple)
and some way of exporting function/macro/etc definitions (like a map)
wondering if the object model could have any object provide a symbol
namespace in addition to a messaging namespace, which I find
intriguing... but need to learn more about racket modules first I
think.

How will Programs refer to each other? Define as inputs, but how will
the reference be written?

I really like the simplicity of defmacro style macros, but without
symbol packages, or lisp2 namespaces they are a bit troublesome. I'm
not sure how to make defmacro work sensibly with a module system
either.

It sounds like the scheme community hasn't decided on a way to handle
this yet either... syntax-case seems like a good bet (although it was
withdrawn?) maybe should just look into how racket does it, but that
is likely way more complicated than needed, due to all the other stuff
racket does around language support.
