(load-as "text" "./scratch/text.lisp")
(load-as "queue" "./scratch/queue.lisp")

(define board-size 10)
(define tile-size 75)

(define buffer (make-image (* board-size tile-size) (* board-size tile-size)))
(define screen-size (make-point (* board-size tile-size) (* board-size tile-size)))

(define (clear-screen!) (fill-rect buffer 0@0 screen-size 0xffffffff))
(define (flip-buffer!) (blit-to-screen buffer 0@0 100 0))

(define board (make-array (* board-size board-size)))
(define moves (make-array (* board-size board-size)))

(define (in-bounds? p)
  (let ((x (point-x p))
        (y (point-y p)))
    (not (or (< x 0) (< y 0) (>= x board-size) (>= y board-size)))))

(define (board-at b p)
  (let ((x (point-x p))
        (y (point-y p)))
    (aget b (+ x (* y board-size)))))

(define (board-at-put b p v)
  (let ((x (point-x p))
        (y (point-y p)))
    (aset b (+ x (* y board-size)) v)))

(define (place-mines board n)
  (let loop ((n n))
       (unless (eq n 0)
         (let* ((x (random board-size)) (y (random board-size)) (p (make-point x y)))
           (cond ((eq -1 (board-at board p)) (loop n)) ;; try again
                 (#t 
                  (board-at-put board p -1)
                  (dolist (dx '(-1 0 1))
                    (dolist (dy '(-1 0 1))
                      (let* ((p (make-point (+ x dx) (+ y dy)))
                             (exist (if (in-bounds? p) (board-at board p) -1)))
                        (unless (eq exist -1)
                          (board-at-put board p (+ 1 exist))))))
                  (loop (- n 1))))))))

(place-mines board 15)

(define (rect x y w h color)
  (let ((a (make-point x y))
        (b (make-point w h)))
    (fill-rect buffer a (point+ a b) color)))

(define (make-color r g b a)
  (bit-or (ash a 24)
          (bit-or (ash r 16)
                  (bit-or (ash g 8) b))))

(define %char-names (vector "0" "1" "2" "3" "4" "5" "6" "7" "8" "9"))

(define (draw-board board)
  (dotimes (y board-size)
    (dotimes (x board-size)
      (let ((it (board-at board (make-point x y)))
            (left (* x tile-size))
            (top (* y tile-size)))
        (rect (+ 1 left)
              (+ 1 top)
              (- tile-size 2)
              (- tile-size 2)
              (if (eq it -1)
                  (make-color 255 0 0 255)
                  (make-color (+ 64 (* it (/ 192 10))) 64 64 255)))
        (cond
          ((eq it -1)
           (text/draw-string buffer "X" (make-point left top) (- tile-size 4) 0.0))
          ((not (eq it 0))
           (text/draw-string buffer (aget %char-names it) (make-point left top) (- tile-size 4) 0.0)))))))

(define (draw-moves moves)
  (dotimes (y board-size)
    (dotimes (x board-size)
      (when (eq 0 (board-at moves (make-point x y)))
        (rect (+ 1 (* x tile-size))
              (+ 1 (* y tile-size))
              (- tile-size 2)
              (- tile-size 2)
              (make-color 128 128 128 255))))))

(define (draw!)
  (clear-screen!)
  (draw-board board)
  (draw-moves moves)
  (flip-buffer!))

(define (should-explore? p)
  (and (in-bounds? p)
       (let ((move (board-at moves p))
             (val  (board-at board p)))
         (not (or (eq move 1) (eq val -1))))))

(define (flood-fill x y done)
  (let ((q (queue/make))
        (seen (make-ht)))
    (let loop ((p (make-point x y)))
         (let ((add (lambda (dx dy)
                      (let ((p2 (point+ p (make-point dx dy))))
                        (unless (not (nil? (ht-at seen p2)))
                          (ht-at-put seen p2 #t)
                          (when (should-explore? p2) (queue/add q p2)))))))
           (cond ((nil? p) (done))
                 (#t (board-at-put moves p 1)
                     (draw!)
                     (sleep-ms 10)
                     (when (eq (board-at board p) 0)
                       (add  1  0)
                       (add -1  0)
                       (add  0  1)
                       (add  0 -1))
                     (loop (queue/pop q))))))))

(define (won?)
  (let ((won #t))
    (dotimes (i (* board-size board-size))
      (let ((move (aget moves i))
            (val  (aget board i)))
        (unless (eq val -1)
          (set! won (and won (eq move 1))))))
    won))

(define (check-win)
  (when (won?) (print "YOU WIN!")))

(define (play-move x y)
  (let* ((here (make-point x y))
         (val  (board-at board here)))
    (cond
      ((eq val -1) (print "YOU LOSE"))
      (#t (fork (flood-fill x y check-win)))))
  (draw!))

(define (onmousedown p)
  (let ((x (point-x p))
        (y (point-y p)))
    (play-move (/ x tile-size) (/ y tile-size))))

(request-display (* board-size tile-size) (* board-size tile-size))

(define (onshow size)
  (draw!))
