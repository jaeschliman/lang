#+TODO: TODO IN-PROGRESS | IGNORE DONE
* DONE stack traces
* DONE move allocations into vm-managed heap
* DONE lists (incl printing)
* DONE lisp reader
* DONE expression compiler
* DONE lambda compiler
* DONE lambdas + closures compiler
* DONE def or define or something
* DONE varargs
* DONE vararg lambda
* DONE quasiquotation
* DONE booleans
* DONE characters
* DONE obj_size function // heap size of object (can be 0 for imms)
* DONE obj_ptrs function // walk Ptr s of obj (use a lambda)
* DONE make stack frames objects
* DONE read string
* DONE tests! (something like an assert)
* DONE bounds checking for heap allocation
* DONE memory usage report function
* DONE if compiler
* DONE simple let
* DONE let + closures
* DONE move symbol table into heap (make it an object)
* DONE vm_map_stack_refs(VM *vm, PtrFn)
* DONE vm_map_reachable_refs(VM *vm) function
* DONE maybe replace 'ffi' with primitives array (simpler for dump/restore?)
* DONE code-generate the prims table. elisp?
* DONE remove the 'ffi' stuff
* DONE scan_heap(mem *start, mem*end) fn (linear scan of objects on the heap)
* DONE garbage collection (cheney?)
* DONE initial audit of requred gc_protect calls
* DONE gc_protect for ptrs
* DONE gc-safe list manipulation functions
* DONE gc-safe allocators / make- functions
* DONE growable ptr array
* DONE growable identity map
* DONE gc-safe reader
* DONE gc-safe BCBuilder
* DONE move varinfo & CompilerEnv into gc heap
* DONE gc-safe compiler
* DONE automatic garbage collection (need to use gc_protect)
* DONE identity hash function
* DONE proper imap
* DONE make cons a defstruct
* TODO move stack memory into vm-managed heap
* DONE stack overlow detection
* DONE continuations / exceptions
* TODO signals
* DONE dump/restore image
* DONE write macroexpander in the language itself
* DONE write reader in the language itself
* DONE basic sdl integration
* DONE single floats
* TODO U32 Array etc
* DONE more prim instrs
* TODO maybe expose bytecode prims as special forms? %push %call etc...
* TODO growable heap
* TODO looping special form (while?)
* DONE TCO
* DONE set!
* TODO set! for more binding contexts
* DONE repl
* DONE basic notebook
* DONE notebook w/ event reactor
* DONE 'load file' vs run file
* TODO rewrite the codegen in the lang itself 
* DONE 'apply'
* DONE basic 'event reactor' runloop -- start with keycodes
* TODO optimize global calls for more arities
* DONE point functions
* DONE real 'built-in-classes' i.e. Cons Fixnum etc
* DONE basic message definition, send facility
* DONE image objects
* DONE rotation + scale BitBlt like thing
* TODO maybe store image data off-heap?
* DONE fix make-point for negative values (was a reader problem)
* DONE more compact bc representation
* TODO compact more of the bc
* DONE generalize blit to work b/t images as well
* DONE blit with mask, src rect, scale, rotation (for both mask and src)
* DONE message send facility
* DONE something resembling OMeta / Meta II
  not as many features, by a long shot, but something basic appears to be working
* DONE optionally plugin in Meta reader as program reader
* DONE basic text rendering
  (very, very basic)
* IGNORE type-of
* DONE class-of
* DONE better float printing (may be missing trailing .0)
* DONE float exponent support?
* TODO more correct float reading support
* TODO unified 'number' type?
* TODO bignums
* TODO clean up callsites of blit- functions
* TODO runtime argument count checking for prims and lambdas
* TODO run on an ipad!
* TODO only update dirty rects?
SDL_UpdateWindowSurfaceRects
https://wiki.libsdl.org/SDL_UpdateWindowSurfaceRects
* TODO warp blit
* TODO simple slideshow program
* TODO ? basic per-file modules ?
* TODO add counters to gensym
* TODO sexpr dot-reader
* DONE audit uses of *_mem functions for GC safety
* DONE apparently we are leaking like crazy somewhere...
* TODO make the lisp programs objects that respond to messages
* DONE ability to load files at the repl
* TODO basic debugger (not that we save debug info, but...)
* DONE some WEIRD bug around hashing -- was seeing the same object change hash codes
  may need to confirm that hash persists across GCs
  by all means it should
* TODO idea: _subclassable_ generic functions
 so each type invocation is a message, and you can subclass the function,
 and so override specific messages.
... but ... not sure if I want subclassing at all...
* TODO multiple return values? check scheme syntax
* TODO 'toplevel' do -- compile/execute exprs sequentially
* TODO some kind of module/object system for L programs
* TODO hygienic macros
http://www.cs.utah.edu/plt/scope-sets/
* TODO read this dissertation on implmentation of scheme
https://www.cs.indiana.edu/~dyb/papers/3imp.pdf
* DONE simple userspace structs (StandardObject)
* TODO convert BC to 32 bit so we can assemble from user space
* TODO adaptons? (see will byrd miniAdapton)
http://adapton.org/
* TODO bezier + fourier transforms is cool!
http://www.jezzamon.com/fourier/index.html
* TODO CFFI
* DONE basic green threading
* DONE basic special variables
* DONE wierd bug -- off-by-one error in vm->pc at termination of final thread
* DONE work out threading issues with run_file
* DONE clean up (new BCBuilder(vm)) callsites (ensure delete)
* TODO CAS for object slots
* DONE userspace print-object (requires output stream)
* TODO a GUI
* TODO a smalltalk-like
* TODO an actor system
* TODO a prolog
* DONE fix special variable integration with continuations
* DONE more thread manipulation functions
  (current-thread)
  (kill-thread thread)
* TODO list-all-threads, thread-status
* DONE semaphore
* TODO mutex etc
* DONE use bitmask for 'primitive' primOps (aka @send apply etc)
* DONE generic maths
* DONE a package system
* DONE hash tables need to grow after threshold
* DONE think about package system syntax for symbols
* DONE should packages be hierarchical?
  want to avoid the problem of name collision for packages.
  perhaps packages should be referred to by a variable binding and the name
  is just for printing? could work better if package object has explicit name bindings
  rather than vars
* DONE start on a 'proper' test suite
  don't want to slow down evolution, but some tests could be useful
* DONE maybe get rid of globals alist
  now we can add a value slot to symbols
* DONE rethink how the `events` executable should work given threading support
  maybe handlers just poke events, there is an event-handling thread,
  and we need a drawing (onframe) thread to be user spawned
  and vm 'just' runs until all threads complete?
* DONE integrate uncaught exceptions with threading
* DONE try to get rid of INTERP_MODE_EXCLUSIVE
* TODO `fill-pattern` blit operation (and with mask)
* TODO add names to threads
* TODO print debug info on receiving a signal
* TODO compiler arity checks
  where to keep the arity info? on the lambdas?
* DONE optional args
* TODO rest args, kwargs
  this will likely be done in userspace
* DONE replace `lambda` with `%nlambda`
  lambda with a name, that can be included in stack traces
* DONE put %nlambda names into stack frames for debugging
* TODO replace `let` with `%let`
  so we can do some type checking etc in `let`
  also named let
* TODO have make-semaphore take a boolean or fixnum param
 when bool, it becomes a binary semaphore
* DONE fix meta1.compiled-reader.lisp RE: threading
* TODO start running user files in a fresh package
* DONE fix issue with resuming continuation over fresh special variables bindings
  need to re-situate special bindings over the new dynamic environment
  where the continuation is executed.
e.g.
 bar = *bar*
 x = (snapshot (binding *foo* 1 (bar)))
 y = (binding *bar* 2 (resume x))
 y should return 2
* TODO weak refs, weak hash tables
* TODO there's no reason for hash tables to use xarray
* TODO use a lookup table on tag bits for class_of
* TODO correct rebase specials alist for initial thread bindings
* TODO process abstraction
  have threads be implicitly owned by a process,
  killing the process kills the threads
* TODO some kind of lisp/smalltalk hybrid for bootstrapping
  may be simplest to make it a smalltalk with lisp escape hatch
  that compiles down to lisp
* TODO disassembler
* TODO macrolet
* TODO remove useless 'vm' args from functions
* TODO thread scheduling needs to be made relative to image startup
  so should walk sleeping threads, subtract now from wait time on save,
  and on restore walk again and add now back in.
* DONE recover from image snapshot call
* DONE snapshot support for graphics sessions
* TODO window resizing
* TODO BC level support for messaging
* TODO think whether we should have inheritance
  I like the idea of object delegation a bit more, it seems more flexible
* TODO `proper` macroexpander that understands lexical scope
* DONE support for command line args in image and boot
* TODO call onshow when booting image as well

* IN-PROGRESS make strings immutable
  with conversion functions <-> mutable arrays of characters
* DONE get rid of the istream nonsense
* TODO could make lists callable
  ((list foo bar baz) a b c) =>
  (baz (bar (foo a b c))) =>
  (reduce-list (lambda (fn acc) (fn acc)) (apply (car fns) args) (cdr args))
* DONE move bc into current frame
* TODO move pc into current frame
* TODO 'better lambda'
* DONE keywords
* DONE use meta reader to save source location info for top-level forms

* TODO pathname utils, e.g. `get-cwd` `chdir` `absolute-path`
* TODO maybe add freetype
https://mrandri19.github.io/2019/07/18/modern-text-rendering-linux-ep1.html
* DONE save-snapshot-and-exit
* DONE switch over to userspace print function
* DONE run tests using built img instead of repeated cold boots
* DONE package/symbol read/print syntax needs to account for smalltalk-like symbols
  e.g. we should allow for free colons in the symbol name
  so perhaps a slash would be a better seperator
  but then need to account for symbols with the name /, /f, /i etc
  and think about how to differentiate the root package
  like it starts with slash? perhaps #/sym for root package symbols
  so then #// would still be viable
* TODO short string optimization
  can fit 10 6 bit chars into a Ptr
* TODO meta reader for repl
* TODO fix race conditions in tl-exception tests
  need a mutex around printing
* TODO think about import vs load syntax
  want to have loaded files always be wrapped in a fresh package
* TODO symbol shadow support
* TODO maybe make keywords their own class
* TODO `find-package`
* TODO transducers, maybe
* TODO heap analysis function
  walk the heap, count items by class and gather memory usage by class
* TODO `unwind-protect`

* notes
maybe have a stack of compilers? can push/pop...
have each compiler pass output to previous one in the stack

how to represent U32 and U64?

how will we pass callbacks through to the VM?  e.g. if I want to map
values of a ht?  safe to 'just' push a stack frame?  but how do we
yield control to the vm, and get it back?

RE: storing image data off-heap: could have a 'byte-blob' object type.
after a gc, scan the old heap for byte-blobs that are not broken hearts,
and free the mem. it's a tradeoff, two heap scans, but less copying.
could become important as there will eventually be many images

RE: meta, would be nice if could have `contextual` in-expr meta, so
that the meta runtime could `push` and `pop` match systems:

(define (copy-from-to a b)
  (let ((i 0))
    (while (< i (length a))
      ;; here we push the `idx` reader which adds supports for subscripts
      ;; for a single expression
      #m idx (set! b[i] i[i])
      (set! i (+ 1 i)))))

(this is actually spelled out in the ometa paper)

also would be nice to add support for arguments, as is done in OMeta
and col/line error reporting :P

need to learn about hygienic macro expansion
need to learn about scm module systems? it looks like racket has a nice one.

I have also been thinking about how to make lisp programs objects.
I want them to respond to messages.

I am wondering if the program should be 'instantiated' or are they
singletons?  it would be a bit hard to know how to parse/update the
class from the editor, or maybe I'm overthinking it?

So a Program would have some sort of contructor (or maybe a couple)
and some way of exporting function/macro/etc definitions (like a map)
wondering if the object model could have any object provide a symbol
namespace in addition to a messaging namespace, which I find
intriguing... but need to learn more about racket modules first I
think.

How will Programs refer to each other? Define as inputs, but how will
the reference be written?

I really like the simplicity of defmacro style macros, but without
symbol packages, or lisp2 namespaces they are a bit troublesome. I'm
not sure how to make defmacro work sensibly with a module system
either.

It sounds like the scheme community hasn't decided on a way to handle
this yet either... syntax-case seems like a good bet (although it was
withdrawn?) maybe should just look into how racket does it, but that
is likely way more complicated than needed, due to all the other stuff
racket does around language support.
